var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a;
import * as React from 'react';
import elementClosestPolyfill from 'element-closest';
export var InputType;
(function (InputType) {
    InputType["Initial"] = "initial";
    InputType["Keyboard"] = "keyboard";
    InputType["Mouse"] = "mouse";
    InputType["Pointer"] = "pointer";
    InputType["Touch"] = "touch";
})(InputType || (InputType = {}));
export var InputEventType;
(function (InputEventType) {
    InputEventType["KeyDown"] = "keydown";
    InputEventType["KeyUp"] = "keyup";
    InputEventType["MouseDown"] = "mousedown";
    InputEventType["MouseMove"] = "mousemove";
    InputEventType["Wheel"] = "wheel";
    InputEventType["MouseWheel"] = "mousewheel";
    InputEventType["DOMMouseScroll"] = "DOMMouseScroll";
    InputEventType["MSPointerDown"] = "MSPointerDown";
    InputEventType["MSPointerMove"] = "MSPointerMove";
    InputEventType["PointerDown"] = "pointerdown";
    InputEventType["PointerMove"] = "pointermove";
    InputEventType["TouchStart"] = "touchstart";
})(InputEventType || (InputEventType = {}));
var formInputs = ['input', 'select', 'textarea'];
var ignoreMap = [
    16,
    17,
    18,
    91,
    93,
];
export var inputEventMap = (_a = {},
    _a[InputEventType.KeyDown] = InputType.Keyboard,
    _a[InputEventType.KeyUp] = InputType.Keyboard,
    _a[InputEventType.MouseDown] = InputType.Mouse,
    _a[InputEventType.MouseMove] = InputType.Mouse,
    _a[InputEventType.Wheel] = InputType.Mouse,
    _a[InputEventType.MouseWheel] = InputType.Mouse,
    _a[InputEventType.DOMMouseScroll] = InputType.Mouse,
    _a[InputEventType.MSPointerDown] = InputType.Pointer,
    _a[InputEventType.MSPointerMove] = InputType.Pointer,
    _a[InputEventType.PointerDown] = InputType.Pointer,
    _a[InputEventType.PointerMove] = InputType.Pointer,
    _a[InputEventType.TouchStart] = InputType.Touch,
    _a);
var pointerMap = {
    2: InputType.Touch,
    3: InputType.Touch,
    4: InputType.Mouse,
};
var getPointerType = function (event) {
    if (typeof event.pointerType === 'number') {
        return pointerMap[event.pointerType];
    }
    else if (event.pointerType === 'mouse') {
        return InputType.Mouse;
    }
    else {
        return InputType.Touch;
    }
};
var detectWheel = function () {
    var wheelType;
    if ('onwheel' in document.createElement('div')) {
        wheelType = 'wheel';
    }
    else {
        wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
    }
    return wheelType;
};
var containerClass = 'wdc-input-provider';
var InputProvider = (function (_super) {
    __extends(InputProvider, _super);
    function InputProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.ref = React.createRef();
        _this.provideIntent = _this.props.provideIntent;
        var storedInput, storedIntent;
        try {
            storedInput = window.sessionStorage.getItem('what-input');
            storedIntent = window.sessionStorage.getItem('what-intent');
        }
        catch (e) {
            console.warn('Failed to retrieve input status from session storage' + e);
        }
        var supportsPassive;
        try {
            var opts = Object.defineProperty({}, 'passive', {
                get: function () {
                    supportsPassive = true;
                },
            });
            var stub = function () {
                return;
            };
            window.addEventListener('test', stub, opts);
            window.removeEventListener('test', stub, opts);
        }
        catch (e) {
            console.warn('Browser does not support passive event listeners');
        }
        _this.state = {
            currentInput: storedInput || InputType.Initial,
            currentIntent: storedIntent || InputType.Initial,
            supportsPassive: supportsPassive || false,
            isBuffering: false,
            isScrolling: false,
            mousePosX: null,
            mousePosY: null,
            nested: false,
        };
        _this.setInput = _this.setInput.bind(_this);
        _this.setIntent = _this.setIntent.bind(_this);
        _this.eventBuffer = _this.eventBuffer.bind(_this);
        return _this;
    }
    InputProvider.prototype.componentDidMount = function () {
        elementClosestPolyfill(window);
        if (this.ref.current &&
            this.ref.current.parentElement &&
            this.ref.current.parentElement.closest("." + containerClass)) {
            this.setState({ nested: true });
            return;
        }
        this.enableListeners(true);
    };
    InputProvider.prototype.componentDidUpdate = function () {
        try {
            window.sessionStorage.setItem('what-input', this.state.currentInput);
            window.sessionStorage.setItem('what-intent', this.state.currentIntent);
        }
        catch (e) {
            console.warn('Failed to set input status in session storage' + e);
        }
    };
    InputProvider.prototype.componentWillUnmount = function () {
        window.clearTimeout(this.eventTimer);
        this.enableListeners(false);
    };
    InputProvider.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        if (nextProps !== this.props ||
            nextState.nested !== this.state.nested ||
            nextState.currentInput !== this.state.currentInput ||
            nextState.currentIntent !== this.state.currentIntent) {
            return true;
        }
        return false;
    };
    InputProvider.prototype.enableListeners = function (enable) {
        if (typeof window === 'undefined') {
            return;
        }
        var options = this.state.supportsPassive
            ? { passive: true }
            : false;
        var fn = enable ? window.addEventListener : window.removeEventListener;
        if (window.PointerEvent) {
            fn('pointerdown', this.setInput);
        }
        else if (window.MSPointerEvent) {
            fn('MSPointerDown', this.setInput);
        }
        else {
            fn('mousedown', this.setInput);
            if ('ontouchstart' in window) {
                fn('touchstart', this.eventBuffer, options);
                fn('touchend', this.setInput);
            }
        }
        if (this.provideIntent) {
            if (window.PointerEvent) {
                fn('pointermove', this.setIntent);
            }
            else if (window.MSPointerEvent) {
                fn('MSPointerMove', this.setIntent);
            }
            else {
                fn('mousemove', this.setIntent);
            }
            fn(detectWheel(), this.setIntent, options);
        }
        fn('keydown', this.eventBuffer);
        fn('keyup', this.eventBuffer);
    };
    InputProvider.prototype.setInput = function (event) {
        if (this.state.isBuffering) {
            return;
        }
        var eventKey = 'which' in event ? event.which : undefined;
        var eventType = event.type;
        var value = inputEventMap[eventType];
        if (value === InputType.Pointer) {
            value = getPointerType(event);
        }
        var ignoreMatch = eventKey ? ignoreMap.indexOf(eventKey) === -1 : undefined;
        var shouldUpdate = (value === InputType.Keyboard && eventKey && ignoreMatch) ||
            value === InputType.Mouse ||
            value === InputType.Touch;
        if (this.state.currentInput !== value && shouldUpdate) {
            this.setState({ currentInput: value });
        }
        if (this.state.currentIntent !== value && shouldUpdate && this.provideIntent) {
            var activeElem = document.activeElement;
            var notFormInput = activeElem &&
                activeElem.nodeName &&
                formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;
            if (notFormInput) {
                this.setState({ currentIntent: value });
            }
        }
    };
    InputProvider.prototype.setIntent = function (event) {
        this.detectScrolling(event);
        if (!this.state.isBuffering && !this.state.isScrolling) {
            var eventType = event.type;
            var value = inputEventMap[eventType];
            if (value === InputType.Pointer) {
                value = getPointerType(event);
            }
            if (this.state.currentIntent !== value) {
                this.setState({ currentIntent: value });
            }
        }
    };
    InputProvider.prototype.eventBuffer = function (event) {
        var _this = this;
        this.setInput(event);
        window.clearTimeout(this.eventTimer);
        this.setState({ isBuffering: true });
        this.eventTimer = window.setTimeout(function () {
            _this.setState({ isBuffering: false });
        }, 100);
    };
    InputProvider.prototype.detectScrolling = function (event) {
        if (this.state.mousePosX !== event.screenX || this.state.mousePosY !== event.screenY) {
            this.setState({
                isScrolling: false,
                mousePosX: event.screenX,
                mousePosY: event.screenY,
            });
        }
        else {
            this.setState({ isScrolling: true });
        }
    };
    InputProvider.prototype.render = function () {
        if (this.state.nested) {
            return this.props.children;
        }
        var intent = this.provideIntent ? this.state.currentIntent : null;
        return (React.createElement("div", { className: containerClass, ref: this.ref, "data-whatinput": this.state.currentInput, "data-whatintent": intent }, this.props.children));
    };
    return InputProvider;
}(React.Component));
export default InputProvider;
